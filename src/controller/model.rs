use axum::{
    extract::Path,
    response::Json,
    routing::{delete, get, post, put},
    Router,
};
use serde::Deserialize;

use crate::{
    controller::BaseError,
    database::model::{Model, Price},
    utils::HttpResult, // Import HttpResult
};

#[derive(Debug, Deserialize)]
pub struct InsertModelRequest {
    pub provider_id: i64,
    pub model_name: String,
    pub real_model_name: Option<String>,
    pub is_deleted: bool,
    pub is_enabled: bool,
}

async fn insert_model(
    Json(request): Json<InsertModelRequest>,
) -> Result<HttpResult<Model>, BaseError> {
    let model = Model {
        id: 0, // Auto-generated by the database
        provider_id: request.provider_id,
        model_name: request.model_name.clone(),
        real_model_name: request.real_model_name.clone(),
        is_deleted: request.is_deleted,
        is_enabled: request.is_enabled,
        created_at: 0, // Auto-generated by the database
        updated_at: 0, // Auto-generated by the database
    };

    Model::insert(&model)?;
    Ok(HttpResult::new(model))
}
async fn delete_model(Path(id): Path<i64>) -> Result<HttpResult<()>, BaseError> {
    Model::delete(id)?;
    Ok(HttpResult::new(()))
}
#[derive(Debug, Deserialize)]
pub struct UpdateModelRequest {
    pub provider_id: Option<i64>,
    pub model_name: Option<String>,
    pub real_model_name: Option<String>,
    pub is_deleted: Option<bool>,
    pub is_enabled: Option<bool>,
}

async fn update_model(
    Path(id): Path<i64>,
    Json(request): Json<UpdateModelRequest>,
) -> Result<HttpResult<Model>, BaseError> {
    let mut model = Model::get(id)?;

    if let Some(provider_id) = request.provider_id {
        model.provider_id = provider_id;
    }
    if let Some(model_name) = request.model_name {
        model.model_name = model_name;
    }
    if let Some(real_model_name) = request.real_model_name {
        model.real_model_name = Some(real_model_name);
    }
    if let Some(is_deleted) = request.is_deleted {
        model.is_deleted = is_deleted;
    }
    if let Some(is_enabled) = request.is_enabled {
        model.is_enabled = is_enabled;
    }

    Model::update(&model)?;
    Ok(HttpResult::new(model))
}
async fn list_models() -> Result<HttpResult<Vec<Model>>, BaseError> {
    let models = Model::list()?;
    Ok(HttpResult::new(models))
}

use chrono::Utc; // Import Utc

#[derive(Debug, Deserialize)]
pub struct InsertPriceRequest {
    // start_time is removed as it will be generated by the server
    pub currency: String,
    pub input_price: i32,
    pub output_price: i32,
    pub input_cache_price: i32,
    pub output_cache_price: i32,
}

async fn insert_model_price(
    Path(model_id): Path<i64>,
    Json(request): Json<InsertPriceRequest>,
) -> Result<HttpResult<Price>, BaseError> {
    // Ensure the model exists before adding a price (optional, but good practice)
    let _ = Model::get(model_id)?;

    let mut price = Price {
        id: 0, // Will be generated by insert_one
        model_id,
        start_time: Utc::now().timestamp_millis(), // Generate start_time on the server
        currency: request.currency,
        input_price: request.input_price,
        output_price: request.output_price,
        input_cache_price: request.input_cache_price,
        output_cache_price: request.output_cache_price,
        created_at: 0, // Will be set by insert_one
        updated_at: 0, // Will be set by insert_one
    };

    Price::insert_one(&mut price)?; // Pass mutable reference
    Ok(HttpResult::new(price)) // Return the created price with generated ID/timestamps
}

async fn list_model_prices(Path(id): Path<i64>) -> Result<HttpResult<Vec<Price>>, BaseError> {
    let prices = Price::list_by_model_id(id)?;
    Ok(HttpResult::new(prices))
}

pub fn create_model_router() -> Router {
    Router::new().nest(
        "/model",
        Router::new()
            .route("/", post(insert_model))
            .route("/list", get(list_models))
            .route("/{id}", delete(delete_model))
            .route("/{id}", put(update_model))
            .route("/{id}/prices", get(list_model_prices)) // List prices for a model
            .route("/{id}/price", post(insert_model_price)), // Add a new price for a model
    )
}
